{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "#These are the libraries you can use.  You may add any libraries directy related to threading if this is a direction\n",
    "#you wish to go (this is not from the course, so it's entirely on you if you wish to use threading).  Any\n",
    "#further libraries you wish to use you must email me, james@uwaterloo.ca, for permission.\n",
    "\n",
    "from IPython.display import display, Math, Latex\n",
    "\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import numpy_financial as npf\n",
    "import yfinance as yf\n",
    "import matplotlib.pyplot as plt\n",
    "import random\n",
    "from datetime import datetime"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Group Assignment\n",
    "### Team Number: 07\n",
    "### Team Member Names: Wendi Xue, \n",
    "### Team Strategy Chosen: Risk-Free(Market Beat, Market Meet, Risk-Free)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Loading and filtering valid tickers\n",
    "In the secret list of tickers that will be used to generate our portfolio, we will take into consideration the following factors:\n",
    "- If there are any duplicate tickers in the list, we will drop them.\n",
    "- If there are any tickers in the list that do not exist, using the function info.get() will prevent any KeyErrors\n",
    "- We only want valid US and Canadian companies that have listed stocks in the markets, so we will only take stocks with United States or Canada as their country and CAD and USD as their currency"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['AAPL', 'ABBV', 'ABT', 'AIG', 'AMZN', 'AXP', 'BA', 'BAC', 'BB.TO', 'BIIB', 'BK', 'BLK', 'BMY', 'C', 'CAT', 'CL', 'KO', 'LLY', 'LMT', 'MO', 'MRK', 'PEP', 'PFE', 'PG', 'PM', 'PYPL', 'QCOM', 'RY.TO', 'SHOP.TO', 'T.TO', 'TD.TO', 'TXN', 'UNH', 'UNP', 'UPS', 'USB']\n"
     ]
    }
   ],
   "source": [
    "# Load the tickers\n",
    "df = pd.read_csv('Tickers_Example.csv', header=None) # test with Tickers_Example.csv?\n",
    "# If there are any duplicate tickers, we will drop them\n",
    "df = df.drop_duplicates()\n",
    "ticker_lst = list(df.iloc[:,0])\n",
    "\n",
    "# Filter out tickers that don't exist; include only valid tickers\n",
    "valid_tickers_lst = []\n",
    "for ticker in ticker_lst:\n",
    "    try: \n",
    "        ticker_data = yf.Ticker(ticker) # call up data\n",
    "        country = ticker_data.info.get('country') \n",
    "        currency = ticker_data.info.get('currency')\n",
    "        if country in {'Canada','United States'} and currency in {'CAD','USD'}: # filters us and canadian tickers and listed stocks\n",
    "            valid_tickers_lst.append(ticker)\n",
    "    except Exception as err:\n",
    "        print(f\"Error: {err}\")\n",
    "\n",
    "print(valid_tickers_lst)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Average daily volume constraint\n",
    "- If the stock does not have any information on their volume on a specific day, we will drop that day.\n",
    "- Between October 1, 2024 and September 30, 2025, we will group together the data of the volume by months to see if there are months with less than 18 trading days. If there is we will drop that month when calculating the average daily volume.\n",
    "- If any stock has an average daily volume below 5,000 shares we will exclude that stock from the list of tickers."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:8: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  data = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\2151039871.py:33: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  daily_data = yf.download(\n"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "['AAPL', 'ABBV', 'ABT', 'AIG', 'AMZN', 'AXP', 'BA', 'BAC', 'BB.TO', 'BIIB', 'BK', 'BLK', 'BMY', 'C', 'CAT', 'CL', 'KO', 'LLY', 'LMT', 'MO', 'MRK', 'PEP', 'PFE', 'PG', 'PM', 'PYPL', 'QCOM', 'RY.TO', 'SHOP.TO', 'T.TO', 'TD.TO', 'TXN', 'UNH', 'UNP', 'UPS', 'USB']\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "[*********************100%***********************]  36 of 36 completed\n"
     ]
    }
   ],
   "source": [
    "# Apply a filter to remove all stocks with volumes below 5000 (in the given period)\n",
    "# period in which we look at the volumes \n",
    "volume_start_date = '2024-10-01'\n",
    "volume_end_date = '2025-09-30' \n",
    "filtered_lst = []\n",
    "\n",
    "for ticker in valid_tickers_lst: # goes through every ticker to filter\n",
    "    data = yf.download(\n",
    "        tickers=ticker,\n",
    "        start=volume_start_date,\n",
    "        end=volume_end_date\n",
    "    )\n",
    "    volume_data = data[['Volume']].dropna() # volume data\n",
    "\n",
    "    keep_months = pd.DataFrame() # df of all the months with more than 18 trading days\n",
    "    volume_data['Month'] = volume_data.index.to_period('M') # create new column of index only by (YYYY-MM)\n",
    "    grouped_month_index = volume_data.groupby(['Month']) # group data by month\n",
    "\n",
    "    for month, group in grouped_month_index:\n",
    "        if len(group) >= 18: # if the month has more than 18 trading days\n",
    "            keep_months = pd.concat([keep_months, group]) # add data of months with more than 18 trading days\n",
    "\n",
    "    average_daily_volume = keep_months['Volume'][ticker].mean() # calculate average daily volume\n",
    "    if average_daily_volume >= 5000: # determine if above or below 5000 shares\n",
    "        filtered_lst.append(ticker) # add to filtered list if greater or equal to 5000 shares\n",
    "\n",
    "print(filtered_lst)\n",
    "\n",
    "# Get the daily data over chosen timeframe (2025-10-24 to 2025-10-31 for testing?)\n",
    "start_date = '2025-10-24' # change to Nov 21 2025\n",
    "end_date = '2025-10-31' # change to Nov 28 2025\n",
    "\n",
    "daily_data = yf.download(\n",
    "    tickers=filtered_lst,\n",
    "    start=start_date,\n",
    "    end=end_date)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "  Ticker  Volatility   Beta      MarketCap              Sector\n",
      "0   AAPL    0.010065  1.109  3968913899520          Technology\n",
      "1   ABBV    0.010006  0.352   413338206208          Healthcare\n",
      "2    ABT    0.009190  0.719   226259664896          Healthcare\n",
      "3    AIG    0.007268  0.622    42697076736  Financial Services\n",
      "4   AMZN    0.020896  1.368  2379107532800   Consumer Cyclical\n"
     ]
    }
   ],
   "source": [
    "# Get/calculate volatility (std), beta, market cap, and sectors\n",
    "\n",
    "# We'll store all the metrics in this dataframe\n",
    "metrics_df = pd.DataFrame(columns=['Ticker', 'Volatility', 'Beta', 'MarketCap', 'Sector'])\n",
    "\n",
    "for ticker in filtered_lst:\n",
    "    # 1. Get price data for this ticker from the daily_data frame\n",
    "    # daily_data has a MultiIndex on the columns: (field, ticker)\n",
    "    try:\n",
    "        prices = daily_data['Adj Close'][ticker]\n",
    "    except KeyError:\n",
    "        # Fallback if Adj Close isn't available\n",
    "        prices = daily_data['Close'][ticker]\n",
    "\n",
    "    # 2. Compute daily returns and volatility (std of returns)\n",
    "    returns = prices.pct_change().dropna()\n",
    "    volatility = returns.std()\n",
    "\n",
    "    # 3. Pull beta, market cap, and sector from Yahoo Finance info\n",
    "    t = yf.Ticker(ticker)\n",
    "    info = t.info\n",
    "\n",
    "    beta = info.get('beta', np.nan)\n",
    "    market_cap = info.get('marketCap', np.nan)\n",
    "    sector = info.get('sector', 'Unknown')\n",
    "\n",
    "    # 4. Append to our metrics dataframe\n",
    "    metrics_df.loc[len(metrics_df)] = [ticker, volatility, beta, market_cap, sector]\n",
    "\n",
    "# Quick look at the result\n",
    "print(metrics_df.head())\n",
    "\n",
    "# Use the weighted scoring algorithm in the doc to provide a score /100 per stock\n",
    "\n",
    "# After scoring, put all stocks in lists based on sector"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Portfolio-Level Risk Metrics\n",
    "We compute risk statistics for every stock that successfully passed our filters.\n",
    "This helps us understand:\n",
    "- Which stocks have the highest/lowest annualized volatility\n",
    "- How each stock behaves vs the S&P500 (beta)\n",
    "- Whether our scoring system aligns with real 1-year risk characteristics\n",
    "- How different sectors compare on risk over a longer horizon\n",
    "\n",
    "This is NOT for the final portfolio —\n",
    "this is only for the universe of stocks actually loaded into the assignment."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\3733541779.py:10: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  raw_data = yf.download(\n",
      "[*********************100%***********************]  36 of 36 completed"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Loaded 1-year return data for universe of stocks.\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n",
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\3733541779.py:30: FutureWarning: The default fill_method='pad' in DataFrame.pct_change is deprecated and will be removed in a future version. Either fill in any non-leading NA values prior to calling pct_change or specify 'fill_method=None' to not fill NA values.\n",
      "  universe_returns = universe_prices.pct_change().dropna()\n"
     ]
    }
   ],
   "source": [
    "# -------------------------------------------------------------------\n",
    "# Get 1-year historical daily data for all loaded + filtered stocks\n",
    "# -------------------------------------------------------------------\n",
    "\n",
    "universe_tickers = filtered_lst[:]   # guaranteed to exist\n",
    "\n",
    "annual_start = \"2024-11-21\"\n",
    "annual_end   = \"2025-11-21\"\n",
    "\n",
    "raw_data = yf.download(\n",
    "    tickers=universe_tickers,\n",
    "    start=annual_start,\n",
    "    end=annual_end\n",
    ")\n",
    "\n",
    "# FIX: Yahoo Finance removed Adj Close as default\n",
    "if isinstance(raw_data.columns, pd.MultiIndex):\n",
    "    # Multi-index case (multiple tickers)\n",
    "    if ('Adj Close' in raw_data.columns.get_level_values(0)):\n",
    "        universe_prices = raw_data['Adj Close']\n",
    "    else:\n",
    "        universe_prices = raw_data['Close']\n",
    "else:\n",
    "    # Single-index (one ticker)\n",
    "    if 'Adj Close' in raw_data.columns:\n",
    "        universe_prices = raw_data['Adj Close']\n",
    "    else:\n",
    "        universe_prices = raw_data['Close']\n",
    "\n",
    "universe_returns = universe_prices.pct_change().dropna()\n",
    "\n",
    "print(\"Loaded 1-year return data for universe of stocks.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Annualized Volatility (All Loaded Stocks):\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Ticker\n",
       "RY.TO      0.162711\n",
       "TD.TO      0.166199\n",
       "KO         0.173028\n",
       "PG         0.181876\n",
       "T.TO       0.183178\n",
       "MO         0.199304\n",
       "CL         0.204902\n",
       "ABT        0.211817\n",
       "UNP        0.223390\n",
       "PEP        0.224181\n",
       "AIG        0.235836\n",
       "BK         0.235975\n",
       "ABBV       0.255632\n",
       "PM         0.256992\n",
       "LMT        0.258922\n",
       "PFE        0.260166\n",
       "BAC        0.266473\n",
       "USB        0.269577\n",
       "BLK        0.270860\n",
       "BMY        0.276683\n",
       "MRK        0.292503\n",
       "C          0.309396\n",
       "CAT        0.310710\n",
       "AXP        0.313433\n",
       "BIIB       0.317621\n",
       "UPS        0.322888\n",
       "AAPL       0.323385\n",
       "AMZN       0.346525\n",
       "BA         0.363089\n",
       "QCOM       0.379716\n",
       "PYPL       0.380434\n",
       "TXN        0.391210\n",
       "LLY        0.400572\n",
       "UNH        0.479202\n",
       "SHOP.TO    0.585218\n",
       "BB.TO      0.605946\n",
       "dtype: float64"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Annualized Variance (All Loaded Stocks):\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Ticker\n",
       "RY.TO      0.026475\n",
       "TD.TO      0.027622\n",
       "KO         0.029939\n",
       "PG         0.033079\n",
       "T.TO       0.033554\n",
       "MO         0.039722\n",
       "CL         0.041985\n",
       "ABT        0.044867\n",
       "UNP        0.049903\n",
       "PEP        0.050257\n",
       "AIG        0.055619\n",
       "BK         0.055684\n",
       "ABBV       0.065348\n",
       "PM         0.066045\n",
       "LMT        0.067041\n",
       "PFE        0.067686\n",
       "BAC        0.071008\n",
       "USB        0.072672\n",
       "BLK        0.073365\n",
       "BMY        0.076554\n",
       "MRK        0.085558\n",
       "C          0.095726\n",
       "CAT        0.096541\n",
       "AXP        0.098240\n",
       "BIIB       0.100883\n",
       "UPS        0.104257\n",
       "AAPL       0.104578\n",
       "AMZN       0.120080\n",
       "BA         0.131834\n",
       "QCOM       0.144184\n",
       "PYPL       0.144730\n",
       "TXN        0.153045\n",
       "LLY        0.160458\n",
       "UNH        0.229635\n",
       "SHOP.TO    0.342480\n",
       "BB.TO      0.367171\n",
       "dtype: float64"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# -------------------------------------------------------------------\n",
    "# Annualized Volatility and Annual Variance for each stock\n",
    "# -------------------------------------------------------------------\n",
    "\n",
    "# Daily → Annual conversion uses 252 trading days\n",
    "annual_volatility = universe_returns.std(ddof=0) * np.sqrt(252)\n",
    "annual_variance   = universe_returns.var(ddof=0) * 252\n",
    "\n",
    "print(\"Annualized Volatility (All Loaded Stocks):\")\n",
    "display(annual_volatility.sort_values())\n",
    "\n",
    "print(\"Annualized Variance (All Loaded Stocks):\")\n",
    "display(annual_variance.sort_values())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Annualized Volatility (All Loaded Stocks):\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Ticker\n",
       "RY.TO      0.162711\n",
       "TD.TO      0.166199\n",
       "KO         0.173028\n",
       "PG         0.181876\n",
       "T.TO       0.183178\n",
       "MO         0.199304\n",
       "CL         0.204902\n",
       "ABT        0.211817\n",
       "UNP        0.223390\n",
       "PEP        0.224181\n",
       "AIG        0.235836\n",
       "BK         0.235975\n",
       "ABBV       0.255632\n",
       "PM         0.256992\n",
       "LMT        0.258922\n",
       "PFE        0.260166\n",
       "BAC        0.266473\n",
       "USB        0.269577\n",
       "BLK        0.270860\n",
       "BMY        0.276683\n",
       "MRK        0.292503\n",
       "C          0.309396\n",
       "CAT        0.310710\n",
       "AXP        0.313433\n",
       "BIIB       0.317621\n",
       "UPS        0.322888\n",
       "AAPL       0.323385\n",
       "AMZN       0.346525\n",
       "BA         0.363089\n",
       "QCOM       0.379716\n",
       "PYPL       0.380434\n",
       "TXN        0.391210\n",
       "LLY        0.400572\n",
       "UNH        0.479202\n",
       "SHOP.TO    0.585218\n",
       "BB.TO      0.605946\n",
       "dtype: float64"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Annualized Variance (All Loaded Stocks):\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "Ticker\n",
       "RY.TO      0.026475\n",
       "TD.TO      0.027622\n",
       "KO         0.029939\n",
       "PG         0.033079\n",
       "T.TO       0.033554\n",
       "MO         0.039722\n",
       "CL         0.041985\n",
       "ABT        0.044867\n",
       "UNP        0.049903\n",
       "PEP        0.050257\n",
       "AIG        0.055619\n",
       "BK         0.055684\n",
       "ABBV       0.065348\n",
       "PM         0.066045\n",
       "LMT        0.067041\n",
       "PFE        0.067686\n",
       "BAC        0.071008\n",
       "USB        0.072672\n",
       "BLK        0.073365\n",
       "BMY        0.076554\n",
       "MRK        0.085558\n",
       "C          0.095726\n",
       "CAT        0.096541\n",
       "AXP        0.098240\n",
       "BIIB       0.100883\n",
       "UPS        0.104257\n",
       "AAPL       0.104578\n",
       "AMZN       0.120080\n",
       "BA         0.131834\n",
       "QCOM       0.144184\n",
       "PYPL       0.144730\n",
       "TXN        0.153045\n",
       "LLY        0.160458\n",
       "UNH        0.229635\n",
       "SHOP.TO    0.342480\n",
       "BB.TO      0.367171\n",
       "dtype: float64"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# -------------------------------------------------------------------\n",
    "# Annualized Volatility and Annual Variance for each stock\n",
    "# -------------------------------------------------------------------\n",
    "\n",
    "# Daily → Annual conversion uses 252 trading days\n",
    "annual_volatility = universe_returns.std(ddof=0) * np.sqrt(252)\n",
    "annual_variance   = universe_returns.var(ddof=0) * 252\n",
    "\n",
    "print(\"Annualized Volatility (All Loaded Stocks):\")\n",
    "display(annual_volatility.sort_values())\n",
    "\n",
    "print(\"Annualized Variance (All Loaded Stocks):\")\n",
    "display(annual_variance.sort_values())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\aaamm\\AppData\\Local\\Temp\\ipykernel_9636\\3570175669.py:7: FutureWarning: YF.download() has changed argument auto_adjust default to True\n",
      "  market_raw = yf.download(\n",
      "[*********************100%***********************]  1 of 1 completed"
     ]
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "1-Year Betas (All Loaded Stocks):\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "T.TO      -0.061993\n",
       "MO        -0.003004\n",
       "CL         0.051363\n",
       "KO         0.054511\n",
       "PM         0.116005\n",
       "PEP        0.143063\n",
       "PG         0.179412\n",
       "LMT        0.200257\n",
       "ABT        0.238938\n",
       "UNH        0.279489\n",
       "BMY        0.292697\n",
       "TD.TO      0.337694\n",
       "MRK        0.344676\n",
       "ABBV       0.424647\n",
       "PFE        0.441161\n",
       "RY.TO      0.533587\n",
       "BIIB       0.570589\n",
       "AIG        0.593218\n",
       "LLY        0.676752\n",
       "UNP        0.694719\n",
       "UPS        0.777471\n",
       "BK         0.927656\n",
       "BAC        1.003832\n",
       "USB        1.071736\n",
       "BLK        1.132373\n",
       "CAT        1.141517\n",
       "BA         1.219830\n",
       "C          1.274359\n",
       "AAPL       1.299759\n",
       "PYPL       1.301612\n",
       "TXN        1.323787\n",
       "AXP        1.369059\n",
       "AMZN       1.391123\n",
       "BB.TO      1.433840\n",
       "QCOM       1.512707\n",
       "SHOP.TO    2.226343\n",
       "dtype: float64"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# -------------------------------------------------------------------\n",
    "# Compute 1-year beta vs S&P 500 for each stock  (FINAL FIXED VERSION)\n",
    "# -------------------------------------------------------------------\n",
    "\n",
    "market_index = \"^GSPC\"\n",
    "\n",
    "market_raw = yf.download(\n",
    "    tickers=market_index,\n",
    "    start=annual_start,\n",
    "    end=annual_end\n",
    ")\n",
    "\n",
    "# Fix Adj Close → Close\n",
    "if 'Adj Close' in market_raw.columns:\n",
    "    market_prices = market_raw['Adj Close']\n",
    "else:\n",
    "    market_prices = market_raw['Close']\n",
    "\n",
    "market_returns = market_prices.pct_change().dropna()\n",
    "\n",
    "# --- FIX: Handle both Series and DataFrame outputs ---\n",
    "if isinstance(market_returns, pd.Series):\n",
    "    market_df = market_returns.to_frame(name=\"Market\")\n",
    "else:\n",
    "    # DataFrame case → rename first column to \"Market\"\n",
    "    col = market_returns.columns[0]\n",
    "    market_df = market_returns.rename(columns={col: \"Market\"})\n",
    "\n",
    "# Align stock universe returns with market returns\n",
    "aligned_returns = universe_returns.join(market_df, how=\"inner\")\n",
    "\n",
    "market_var = aligned_returns[\"Market\"].var(ddof=0)\n",
    "\n",
    "beta_dict = {}\n",
    "\n",
    "for t in universe_returns.columns:\n",
    "    try:\n",
    "        cov_sm = aligned_returns[[t, \"Market\"]].cov(ddof=0).iloc[0, 1]\n",
    "        beta_dict[t] = cov_sm / market_var\n",
    "    except:\n",
    "        beta_dict[t] = np.nan\n",
    "\n",
    "beta_series = pd.Series(beta_dict)\n",
    "\n",
    "print(\"1-Year Betas (All Loaded Stocks):\")\n",
    "display(beta_series.sort_values())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "metrics_df updated with annual volatility, variance, and 1-year beta:\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Ticker</th>\n",
       "      <th>Volatility</th>\n",
       "      <th>Beta</th>\n",
       "      <th>MarketCap</th>\n",
       "      <th>Sector</th>\n",
       "      <th>AnnualVol</th>\n",
       "      <th>AnnualVar</th>\n",
       "      <th>Beta_1Y</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>AAPL</td>\n",
       "      <td>0.010065</td>\n",
       "      <td>1.109</td>\n",
       "      <td>3968913899520</td>\n",
       "      <td>Technology</td>\n",
       "      <td>0.323385</td>\n",
       "      <td>0.104578</td>\n",
       "      <td>1.299759</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>ABBV</td>\n",
       "      <td>0.010006</td>\n",
       "      <td>0.352</td>\n",
       "      <td>413338206208</td>\n",
       "      <td>Healthcare</td>\n",
       "      <td>0.255632</td>\n",
       "      <td>0.065348</td>\n",
       "      <td>0.424647</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>ABT</td>\n",
       "      <td>0.009190</td>\n",
       "      <td>0.719</td>\n",
       "      <td>226259664896</td>\n",
       "      <td>Healthcare</td>\n",
       "      <td>0.211817</td>\n",
       "      <td>0.044867</td>\n",
       "      <td>0.238938</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>AIG</td>\n",
       "      <td>0.007268</td>\n",
       "      <td>0.622</td>\n",
       "      <td>42697076736</td>\n",
       "      <td>Financial Services</td>\n",
       "      <td>0.235836</td>\n",
       "      <td>0.055619</td>\n",
       "      <td>0.593218</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>AMZN</td>\n",
       "      <td>0.020896</td>\n",
       "      <td>1.368</td>\n",
       "      <td>2379107532800</td>\n",
       "      <td>Consumer Cyclical</td>\n",
       "      <td>0.346525</td>\n",
       "      <td>0.120080</td>\n",
       "      <td>1.391123</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "  Ticker  Volatility   Beta      MarketCap              Sector  AnnualVol  \\\n",
       "0   AAPL    0.010065  1.109  3968913899520          Technology   0.323385   \n",
       "1   ABBV    0.010006  0.352   413338206208          Healthcare   0.255632   \n",
       "2    ABT    0.009190  0.719   226259664896          Healthcare   0.211817   \n",
       "3    AIG    0.007268  0.622    42697076736  Financial Services   0.235836   \n",
       "4   AMZN    0.020896  1.368  2379107532800   Consumer Cyclical   0.346525   \n",
       "\n",
       "   AnnualVar   Beta_1Y  \n",
       "0   0.104578  1.299759  \n",
       "1   0.065348  0.424647  \n",
       "2   0.044867  0.238938  \n",
       "3   0.055619  0.593218  \n",
       "4   0.120080  1.391123  "
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# -------------------------------------------------------------------\n",
    "# Merge the 1-year risk metrics back into metrics_df\n",
    "# -------------------------------------------------------------------\n",
    "\n",
    "metrics_df['AnnualVol'] = metrics_df['Ticker'].map(annual_volatility)\n",
    "metrics_df['AnnualVar'] = metrics_df['Ticker'].map(annual_variance)\n",
    "metrics_df['Beta_1Y']   = metrics_df['Ticker'].map(beta_series)\n",
    "\n",
    "print(\"metrics_df updated with annual volatility, variance, and 1-year beta:\")\n",
    "display(metrics_df.head())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Scoring completed. Preview:\n"
     ]
    },
    {
     "data": {
      "text/html": [
       "<div>\n",
       "<style scoped>\n",
       "    .dataframe tbody tr th:only-of-type {\n",
       "        vertical-align: middle;\n",
       "    }\n",
       "\n",
       "    .dataframe tbody tr th {\n",
       "        vertical-align: top;\n",
       "    }\n",
       "\n",
       "    .dataframe thead th {\n",
       "        text-align: right;\n",
       "    }\n",
       "</style>\n",
       "<table border=\"1\" class=\"dataframe\">\n",
       "  <thead>\n",
       "    <tr style=\"text-align: right;\">\n",
       "      <th></th>\n",
       "      <th>Ticker</th>\n",
       "      <th>Volatility</th>\n",
       "      <th>Beta</th>\n",
       "      <th>MarketCap</th>\n",
       "      <th>VolPts</th>\n",
       "      <th>BetaPts</th>\n",
       "      <th>CapPts</th>\n",
       "      <th>Score</th>\n",
       "    </tr>\n",
       "  </thead>\n",
       "  <tbody>\n",
       "    <tr>\n",
       "      <th>0</th>\n",
       "      <td>AAPL</td>\n",
       "      <td>0.010065</td>\n",
       "      <td>1.109</td>\n",
       "      <td>3968913899520</td>\n",
       "      <td>45</td>\n",
       "      <td>10</td>\n",
       "      <td>20</td>\n",
       "      <td>75</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>1</th>\n",
       "      <td>ABBV</td>\n",
       "      <td>0.010006</td>\n",
       "      <td>0.352</td>\n",
       "      <td>413338206208</td>\n",
       "      <td>45</td>\n",
       "      <td>35</td>\n",
       "      <td>20</td>\n",
       "      <td>100</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>2</th>\n",
       "      <td>ABT</td>\n",
       "      <td>0.009190</td>\n",
       "      <td>0.719</td>\n",
       "      <td>226259664896</td>\n",
       "      <td>45</td>\n",
       "      <td>25</td>\n",
       "      <td>20</td>\n",
       "      <td>90</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>3</th>\n",
       "      <td>AIG</td>\n",
       "      <td>0.007268</td>\n",
       "      <td>0.622</td>\n",
       "      <td>42697076736</td>\n",
       "      <td>45</td>\n",
       "      <td>25</td>\n",
       "      <td>12</td>\n",
       "      <td>82</td>\n",
       "    </tr>\n",
       "    <tr>\n",
       "      <th>4</th>\n",
       "      <td>AMZN</td>\n",
       "      <td>0.020896</td>\n",
       "      <td>1.368</td>\n",
       "      <td>2379107532800</td>\n",
       "      <td>40</td>\n",
       "      <td>0</td>\n",
       "      <td>20</td>\n",
       "      <td>60</td>\n",
       "    </tr>\n",
       "  </tbody>\n",
       "</table>\n",
       "</div>"
      ],
      "text/plain": [
       "  Ticker  Volatility   Beta      MarketCap  VolPts  BetaPts  CapPts  Score\n",
       "0   AAPL    0.010065  1.109  3968913899520      45       10      20     75\n",
       "1   ABBV    0.010006  0.352   413338206208      45       35      20    100\n",
       "2    ABT    0.009190  0.719   226259664896      45       25      20     90\n",
       "3    AIG    0.007268  0.622    42697076736      45       25      12     82\n",
       "4   AMZN    0.020896  1.368  2379107532800      40        0      20     60"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    }
   ],
   "source": [
    "# -------------------------------------------------------------------\n",
    "# Apply Weighted Scoring Algorithm (Volatility + Beta + Market Cap)\n",
    "# Ammar\n",
    "# -------------------------------------------------------------------\n",
    "\n",
    "scored_df = metrics_df.copy()\n",
    "\n",
    "# --- Volatility scoring ---\n",
    "def vol_points(v):\n",
    "    # v is daily volatility (e.g., 0.02 = 2%)\n",
    "    if v < 0.02:\n",
    "        return 45\n",
    "    elif v < 0.03:\n",
    "        return 40\n",
    "    elif v < 0.04:\n",
    "        return 35\n",
    "    elif v < 0.05:\n",
    "        return 25\n",
    "    elif v < 0.06:\n",
    "        return 15\n",
    "    else:\n",
    "        return 5\n",
    "\n",
    "# --- Beta scoring ---\n",
    "def beta_points(b):\n",
    "    if pd.isna(b):\n",
    "        return 20  # neutral fallback if beta missing\n",
    "    if b < 0.6:\n",
    "        return 35\n",
    "    elif b < 0.9:\n",
    "        return 25\n",
    "    elif b < 1.1:\n",
    "        return 20\n",
    "    elif b < 1.3:\n",
    "        return 10\n",
    "    else:\n",
    "        return 0\n",
    "\n",
    "# --- Market Cap scoring ---\n",
    "def cap_points(m):\n",
    "    if m > 200e9:\n",
    "        return 20\n",
    "    elif m >= 50e9:\n",
    "        return 16\n",
    "    elif m >= 10e9:\n",
    "        return 12\n",
    "    elif m >= 2e9:\n",
    "        return 8\n",
    "    else:\n",
    "        return 4\n",
    "\n",
    "# Assign points\n",
    "scored_df[\"VolPts\"]  = scored_df[\"Volatility\"].apply(vol_points)\n",
    "scored_df[\"BetaPts\"] = scored_df[\"Beta\"].apply(beta_points)\n",
    "scored_df[\"CapPts\"]  = scored_df[\"MarketCap\"].apply(cap_points)\n",
    "\n",
    "# Final composite score out of 100\n",
    "scored_df[\"Score\"] = scored_df[\"VolPts\"] + scored_df[\"BetaPts\"] + scored_df[\"CapPts\"]\n",
    "\n",
    "print(\"Scoring completed. Preview:\")\n",
    "display(scored_df[[\"Ticker\", \"Volatility\", \"Beta\", \"MarketCap\", \"VolPts\", \"BetaPts\", \"CapPts\", \"Score\"]].head())\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Technology: ['AAPL', 'BB.TO', 'QCOM', 'SHOP.TO', 'TXN']\n",
      "Healthcare: ['ABBV', 'ABT', 'BIIB', 'BMY', 'LLY', 'MRK', 'PFE', 'UNH']\n",
      "Financial Services: ['AIG', 'AXP', 'BAC', 'BK', 'BLK', 'C', 'PYPL', 'RY.TO', 'TD.TO', 'USB']\n",
      "Consumer Cyclical: ['AMZN']\n",
      "Industrials: ['BA', 'CAT', 'LMT', 'UNP', 'UPS']\n",
      "Consumer Defensive: ['CL', 'KO', 'MO', 'PEP', 'PG', 'PM']\n",
      "Communication Services: ['T.TO']\n"
     ]
    }
   ],
   "source": [
    "# -------------------------------------------------------------------\n",
    "# After scoring, put all stocks in lists based on sector\n",
    "# Ammar\n",
    "# -------------------------------------------------------------------\n",
    "\n",
    "sector_dict = {}   # sector → list of tickers\n",
    "\n",
    "for _, row in scored_df.iterrows():\n",
    "    sector = row[\"Sector\"]\n",
    "    ticker = row[\"Ticker\"]\n",
    "    \n",
    "    # Create sector key if it doesn't exist\n",
    "    if sector not in sector_dict:\n",
    "        sector_dict[sector] = []\n",
    "    \n",
    "    # Append ticker\n",
    "    sector_dict[sector].append(ticker)\n",
    "\n",
    "# Preview grouping\n",
    "for sec, tickers in sector_dict.items():\n",
    "    print(f\"{sec}: {tickers}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Forming the top 25 stocks dataframe\n",
    "- To maximize our diversification, we will select the top 25 stocks according to the scores allocated by our scoring algorithm, which is the maximum amount we are allowed to have. This will protect our portfolio from single-company risk.\n",
    "- Using the concept of diversification, we will also spread our selection of stocks accross all sectors so that our portfolio is not entirely dependent on the how well a specific sector performs. Thus, we will pick the top 5 stocks, or the maximum amount of stocks if there are less than 5, with the best score from each sector and from that, we will pick the top 25 stocks with the best scores. This way we will not have more than 5 stocks per sector.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Take the top 5 from each sector (based on their score /100) and put them in a new dataframe\n",
    "top5_count = 0\n",
    "sector_top5 = pd.DataFrame() # top 5 tickers of a sector with the best scoring\n",
    "def sector_top5(df,sector):\n",
    "    for ticker in df['Ticker'].tolist():\n",
    "        if df.loc[ticker,'Sector'] == sector:\n",
    "            top5_count += 1\n",
    "            if top5_count > 5:\n",
    "                top5_count = 5\n",
    "                smallest_score = sector_top5['Score'].min()\n",
    "                smallest_score_index = df.index(smallest_score)\n",
    "                if df.loc[ticker,'Score'] > smallest_score:\n",
    "                    sector_top5.loc[smallest_score_index] = df[ticker]\n",
    "            else:\n",
    "                sector_top5 = pd.concat([sector_top5,df[ticker]])\n",
    "\n",
    "sector_lst = df['Sector'].unique # creates a list of all the sectors\n",
    "all_sectors_top5 = pd.DataFrame()\n",
    "for sector in sector_lst:\n",
    "    df_sector_top5 = sector_top5(df,sector)\n",
    "    all_sectors_top5 = pd.concat([all_sectors_top5,df_sector_top5])\n",
    "\n",
    "# Then return the top 25\n",
    "# sort stocks from highest score to lowest\n",
    "all_sectors_top5 = all_sectors_top5.sort_values('Score', ascending=False)\n",
    "top_25_stocks = all_sectors_top5.head(25) # top 25 stocks"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Market Cap Mix: Check for a small-cap\n",
    "To meet the requirement of at least one small-cap:\n",
    "- Check if the 25th stock in our dataframe is a small-cap (we will need the last row of the dataframe to be a small-cap for the mininum variance portfolio optimization). If it is we will proceed with the minimum varaicnace portfolio optimization.\n",
    "- If the last row is not a small-cap, check if there already is a small-cap in the entire top 25 stocks. If there is a small-cap, we will move the first small-cap we find in the dataframe to the last row to fufill the requirement for our minimum variance optimization.\n",
    "- If our top 25 stocks dataframe does not contain a small-cap, we will take the best scoring small-cap from the entire list of tickers and we will replace the last row of our top 25 stocks with it."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# check for small cap in the last row of the top 25 stocks as code determining weight of portfolio will consider this\n",
    "small_cap = 2e9\n",
    "last_row_market_cap = top_25_stocks['MarketCap'].iloc[-1]\n",
    "market_cap = top_25_stocks['MarketCap']\n",
    "if last_row_market_cap < small_cap:\n",
    "    print(\"Small cap in the 25th row found\")\n",
    "# move small cap to the last row if there is a small cap in the top 25 stocks\n",
    "elif (market_cap < small_cap).any():\n",
    "    for row in top_25_stocks.itertuples():\n",
    "        if row.MarketCap < small_cap:\n",
    "            top_25_stocks = top_25_stocks.drop(row)\n",
    "            top_25_stocks = pd.concat([top_25_stocks,row])\n",
    "# get the best scoring small cap from the dataframe of the top 5 of all sectors and replace it with the stock of the last row of the top 25 stocks            \n",
    "else:\n",
    "    small_cap_df = pd.DataFrame()\n",
    "    for row in all_sectors_top5.itertuples(): # change to metrics dataframe\n",
    "        if row.MarketCap < small_cap:\n",
    "            small_cap_df = pd.concat(small_cap_df,row)\n",
    "        break\n",
    "    small_cap_df = small_cap_df.sort_values('Score', ascending=False)\n",
    "    top_score_small_cap = small_cap_df.iloc[0]\n",
    "    # replace the last stock of the top 25 with the small cap with the best score\n",
    "    top_25_stocks.iloc[-1] = top_score_small_cap"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Contribution Declaration\n",
    "\n",
    "The following team members made a meaningful contribution to this assignment:\n",
    "\n",
    "Insert Names Here."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
